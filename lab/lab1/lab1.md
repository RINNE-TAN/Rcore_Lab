# Lab 1

阅读完了实验指导0和1，主要掌握了中断相关的内容，以下是一部分理解

## 主动产生中断并进行测试的方法

1. 通过内联汇编调用ebreak

   ```rust
   unsafe { llvm_asm!("ebreak") };
   ```

2. 访问非法内存，在jal rust_main启动后通过去访问0x0地址来产生异常

   ```assembly
   jr x0
   ```

3. 设置时钟中断，在timer.rs当中，init初始化的时候，先设置了允许时钟中断，并且在此之后调用了set_next_timeout()，这个方法进行了sbi中的SBI_SET_TIMER调用，设置了下一次时钟中断的时间

   ```rust
   pub fn init() {
       unsafe {
           // 开启 STIE，允许时钟中断
           sie::set_stimer();
           // 开启 SIE（不是 sie 寄存器），允许内核态被中断打断
           sstatus::set_sie();
       }
       // 设置下一次时钟中断
       set_next_timeout();
   }
   sbi_call(SBI_SET_TIMER, time, 0, 0);
   ```
## 中断的处理流程

   先通过scause寄存器判断中断类型，是异常（非法访问内存），陷阱，还是硬件中断（时钟中断），

   scause记录中断原因，然后stvec记录中断具体信息，通过这两个信息来定位中断的问题并进行处理。

## 关于时钟中断的一些理解

在计算机组成中，存在被称为硬件时钟的部分，即RTC（Real Time Clock，实时时钟），该部分和操作系统无关，在开启时钟中断后， Linux 的 OS 时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入 CPU，就可以引发一个中断请求信号，我们就把它叫做时钟中断。在时钟中断的过程中，主要处理和时间相关的信息，如系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器，进程更新后的时间片为**进程调度**提供依据，然后在**时钟中断返回时决定是否要执行调度程序**。

## 该实验的完成内容

在判断中断类型的时候多加了一个匹配，去匹配访问非法内存的情况，同时通过判断stval的内容来定位到异常发生的地址，这里对访问0x0内存的异常进行了处理。

    ```rust
    // 访问不存在地址
        Trap::Exception(Exception::LoadFault) => {
            if stval == 0 {
                println!("Success!");
            }
            panic!();
        }
    ```

主动访问0x0地址来导致异常并测试

    ```assembly
    jr x0
    ```

